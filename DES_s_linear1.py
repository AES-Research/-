
S_i_mask = [
            [
                [
                    -32 for beta in range(16)
                ]for alpha in range(64)
            ]for i in range(8)
]

hex_bin_box = {
        '0': '0000', '1': '0001', '2': '0010', '3': '0011',
        '4': '0100', '5': '0101', '6': '0110', '7': '0111',
        '8': '1000', '9': '1001', 'a': '1010', 'b': '1011',
        'c': '1100', 'd': '1101', 'e': '1110', 'f': '1111',
}

hex2bin = lambda hexstr: ''.join(hex_bin_box[i] for i in hexstr)             #用于16进制字符串转二进制字符串

int2bit6 = lambda num: '{:0>6}'.format(bin(num)[2:])    #用于10进制数字转二进制字符串
int2bit4 = lambda num: '{:0>4}'.format(bin(num)[2:])
xor_bstr = lambda a,b: hex2bin(hex(int(a, 2) ^ int(b, 2))[2:])  #两个二进制字符串异或，返回二进制字符串异或值

def self_xor(num,wide):
    count=0
    for i in range(wide):
        if (num&1):
            count+=1
        num>>=1
    if(count%2==0):  #偶数个1异或就是0，
        return 0
    return 1         #奇数个1异或就是1，



S_box = [
        [
                0xe, 0x4, 0xd, 0x1, 0x2, 0xf, 0xb, 0x8, 0x3, 0xa, 0x6, 0xc, 0x5, 0x9, 0x0, 0x7,
                0x0, 0xf, 0x7, 0x4, 0xe, 0x2, 0xd, 0x1, 0xa, 0x6, 0xc, 0xb, 0x9, 0x5, 0x3, 0x8,
                0x4, 0x1, 0xe, 0x8, 0xd, 0x6, 0x2, 0xb, 0xf, 0xc, 0x9, 0x7, 0x3, 0xa, 0x5, 0x0,
                0xf, 0xc, 0x8, 0x2, 0x4, 0x9, 0x1, 0x7, 0x5, 0xb, 0x3, 0xe, 0xa, 0x0, 0x6, 0xd,
        ],
        [
                0xf, 0x1, 0x8, 0xe, 0x6, 0xb, 0x3, 0x4, 0x9, 0x7, 0x2, 0xd, 0xc, 0x0, 0x5, 0xa,
                0x3, 0xd, 0x4, 0x7, 0xf, 0x2, 0x8, 0xe, 0xc, 0x0, 0x1, 0xa, 0x6, 0x9, 0xb, 0x5,
                0x0, 0xe, 0x7, 0xb, 0xa, 0x4, 0xd, 0x1, 0x5, 0x8, 0xc, 0x6, 0x9, 0x3, 0x2, 0xf,
                0xd, 0x8, 0xa, 0x1, 0x3, 0xf, 0x4, 0x2, 0xb, 0x6, 0x7, 0xc, 0x0, 0x5, 0xe, 0x9,
        ],
        [
                0xa, 0x0, 0x9, 0xe, 0x6, 0x3, 0xf, 0x5, 0x1, 0xd, 0xc, 0x7, 0xb, 0x4, 0x2, 0x8,
                0xd, 0x7, 0x0, 0x9, 0x3, 0x4, 0x6, 0xa, 0x2, 0x8, 0x5, 0xe, 0xc, 0xb, 0xf, 0x1,
                0xd, 0x6, 0x4, 0x9, 0x8, 0xf, 0x3, 0x0, 0xb, 0x1, 0x2, 0xc, 0x5, 0xa, 0xe, 0x7,
                0x1, 0xa, 0xd, 0x0, 0x6, 0x9, 0x8, 0x7, 0x4, 0xf, 0xe, 0x3, 0xb, 0x5, 0x2, 0xc,
        ],
        [
                0x7, 0xd, 0xe, 0x3, 0x0, 0x6, 0x9, 0xa, 0x1, 0x2, 0x8, 0x5, 0xb, 0xc, 0x4, 0xf,
                0xd, 0x8, 0xb, 0x5, 0x6, 0xf, 0x0, 0x3, 0x4, 0x7, 0x2, 0xc, 0x1, 0xa, 0xe, 0x9,
                0xa, 0x6, 0x9, 0x0, 0xc, 0xb, 0x7, 0xd, 0xf, 0x1, 0x3, 0xe, 0x5, 0x2, 0x8, 0x4,
                0x3, 0xf, 0x0, 0x6, 0xa, 0x1, 0xd, 0x8, 0x9, 0x4, 0x5, 0xb, 0xc, 0x7, 0x2, 0xe,
        ],
        [
                0x2, 0xc, 0x4, 0x1, 0x7, 0xa, 0xb, 0x6, 0x8, 0x5, 0x3, 0xf, 0xd, 0x0, 0xe, 0x9,
                0xe, 0xb, 0x2, 0xc, 0x4, 0x7, 0xd, 0x1, 0x5, 0x0, 0xf, 0xa, 0x3, 0x9, 0x8, 0x6,
                0x4, 0x2, 0x1, 0xb, 0xa, 0xd, 0x7, 0x8, 0xf, 0x9, 0xc, 0x5, 0x6, 0x3, 0x0, 0xe,
                0xb, 0x8, 0xc, 0x7, 0x1, 0xe, 0x2, 0xd, 0x6, 0xf, 0x0, 0x9, 0xa, 0x4, 0x5, 0x3,
        ],
        [
                0xc, 0x1, 0xa, 0xf, 0x9, 0x2, 0x6, 0x8, 0x0, 0xd, 0x3, 0x4, 0xe, 0x7, 0x5, 0xb,
                0xa, 0xf, 0x4, 0x2, 0x7, 0xc, 0x9, 0x5, 0x6, 0x1, 0xd, 0xe, 0x0, 0xb, 0x3, 0x8,
                0x9, 0xe, 0xf, 0x5, 0x2, 0x8, 0xc, 0x3, 0x7, 0x0, 0x4, 0xa, 0x1, 0xd, 0xb, 0x6,
                0x4, 0x3, 0x2, 0xc, 0x9, 0x5, 0xf, 0xa, 0xb, 0xe, 0x1, 0x7, 0x6, 0x0, 0x8, 0xd,
        ],
        [
                0x4, 0xb, 0x2, 0xe, 0xf, 0x0, 0x8, 0xd, 0x3, 0xc, 0x9, 0x7, 0x5, 0xa, 0x6, 0x1,
                0xd, 0x0, 0xb, 0x7, 0x4, 0x9, 0x1, 0xa, 0xe, 0x3, 0x5, 0xc, 0x2, 0xf, 0x8, 0x6,
                0x1, 0x4, 0xb, 0xd, 0xc, 0x3, 0x7, 0xe, 0xa, 0xf, 0x6, 0x8, 0x0, 0x5, 0x9, 0x2,
                0x6, 0xb, 0xd, 0x8, 0x1, 0x4, 0xa, 0x7, 0x9, 0x5, 0x0, 0xf, 0xe, 0x2, 0x3, 0xc,
        ],
        [
                0xd, 0x2, 0x8, 0x4, 0x6, 0xf, 0xb, 0x1, 0xa, 0x9, 0x3, 0xe, 0x5, 0x0, 0xc, 0x7,
                0x1, 0xf, 0xd, 0x8, 0xa, 0x3, 0x7, 0x4, 0xc, 0x5, 0x6, 0xb, 0x0, 0xe, 0x9, 0x2,
                0x7, 0xb, 0x4, 0x1, 0x9, 0xc, 0xe, 0x2, 0x0, 0x6, 0xa, 0xd, 0xf, 0x3, 0x5, 0x8,
                0x2, 0x1, 0xe, 0x7, 0x4, 0xa, 0x8, 0xd, 0xf, 0xc, 0x9, 0x0, 0x3, 0x5, 0x6, 0xb,
        ],
]

#将输入的int过 S 盒，再转为int，返回int
def S(i,IN):
    bit6 = int2bit6(IN)
    location = int(bit6[0]+bit6[-1],2)*16 + int(bit6[1:-1],2)
    return int(S_box[i][location])

def get_S_i_mask():
    for i in range(8):
        for alpha in range(64):
            for beta in range(16):
                for x in range(64):
                    if(self_xor(x & alpha,6)==self_xor(S(i,x) & beta,4)):
                        S_i_mask[i][alpha][beta] += 1

def print_S_i_mask(num):
    print('\t\t\t\t\tS{}线性分布表'.format(num))
    print('α\β\t',end='')
    for i in range(16):
        print(i,end='\t')
    print('\n')
    count = 0
    for alpha in S_i_mask[num-1]:
        print(count,end='\t\t')
        count +=1
        for NS in alpha:
            print(NS,end='\t')
        print('\n')

def get_best_linear(num):
    max = [0,0,0]  #(alpha,beta,NS)
    for i in range(1,64):
        for j in range(16):
            if abs(S_i_mask[num][i][j]) > abs(max[-1]):
                max[0],max[1],max[2] = i,j,S_i_mask[num][i][j]
    #print(max)
    maxs=[]
    for i in range(1,64):
        try:
            maxs.append([i, S_i_mask[num][i].index(max[-1]), max[-1]])
        except ValueError:
            pass

    # E扩展
    E_box = [
        32, 1, 2, 3, 4, 5,
        4, 5, 6, 7, 8, 9,
        8, 9, 10, 11, 12, 13,
        12, 13, 14, 15, 16, 17,
        16, 17, 18, 19, 20, 21,
        20, 21, 22, 23, 24, 25,
        24, 25, 26, 27, 28, 29,
        28, 29, 30, 31, 32, 1,
    ]

    # P盒
    P_box = [
        16, 7, 20, 21, 29, 12, 28, 17,
        1, 15, 23, 26, 5, 18, 31, 10,
        2, 8, 24, 14, 32, 27, 3, 9,
        19, 13, 30, 6, 22, 11, 4, 25,
    ]


    #print(maxs)
    print('在第{}个S盒中：'.format(num+1))
    for item in maxs:
        a = int2bit6(item[0])
        b = int2bit4(item[1])
        ##要通过a和b确定秘钥位置，这是第num个盒子，
        #求(E(R0)xorK0)·a的位置
        alpha_loca = []
        beta_loca = []
        for i in range(6):
            if a[i]=='1':
                alpha_loca.append(num*6+i)   # 此时是左向右计数,从0开始计
        for i in range(4):
            if b[i]=='1':
                beta_loca.append(num*4+i)   # 此时是左向右计数
        R_local = []
        K_local = []
        F_local = []
        for i in alpha_loca:
            R_local.append(32 - E_box[i])     # 此时是从右开始计数，左到右分别是 31,30,29......2,1,0
            K_local.append(47 - i)
        for i in beta_loca:
            F_local.append(31-P_box.index(i+1))
        print('\tα={},β={},NS={},\t逼近式：P_low{r}⊕C_low{r}⊕P_h{f}⊕C_h{f}=K1{k}⊕K3{k}'.
              format(item[0],item[1],item[-1],r=R_local,f=F_local,k=K_local))
        # print('\t$α={},β={}$,NS={},\t逼近式：$P_L{r}\oplus C_L{r}\oplus P_H{f}\oplus C_H{f}=K_1{k}\oplus K_3{k}$'.
        #       format(item[0], item[1], item[-1], r=R_local, f=F_local, k=K_local))

if __name__=='__main__':
    #print_S_i_mask(1)
    get_S_i_mask()
    #print_S_i_mask(1)
    print('最佳线性逼近式如下：')
    for i in range(8):
        get_best_linear(i)
